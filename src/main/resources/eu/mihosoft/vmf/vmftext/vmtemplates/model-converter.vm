#*
 * Copyright 2016-2017 Michael Hoffer <info@michaelhoffer.de>. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * If you use this software for scientific research then please cite the following publication(s):
 *
 * M. Hoffer, C. Poliwoda, & G. Wittum. (2013). Visual reflection library:
 * a framework for declarative GUI programming on the Java platform.
 * Computing and Visualization in Science, 2013, 16(4),
 * 181â€“192. http://doi.org/10.1007/s00791-014-0230-y
 *#
package ${packageName};

// java core imports
import java.util.List;
import java.util.stream.Collectors;
import java.io.File;
import java.io.InputStream;
import java.io.FileInputStream;
import java.io.IOException;

// antlr4 imports
import org.antlr.v4.runtime.CharStream;
import org.antlr.v4.runtime.CharStreams;
import org.antlr.v4.runtime.CommonTokenStream;

// model imports
import ${modelPackageName}.*;
import static ${packageName}.${Util.firstToUpper($model.grammarName)}Parser.*;

public final class ${Util.firstToUpper($model.grammarName)}ModelConverter {

    public ${Util.firstToUpper($model.grammarName)}ModelConverter() {
      // throw new AssertionError("Don't instantiate me!");
    }

    public ${Util.firstToUpper($model.grammarName)}Model convertToModel(File code) throws IOException{
        InputStream codeStream = new FileInputStream(code);
        CharStream input = CharStreams.fromStream(codeStream);

        ${Util.firstToUpper($model.grammarName)}Lexer lexer = new ${Util.firstToUpper($model.grammarName)}Lexer(input);
        CommonTokenStream tokens = new CommonTokenStream(lexer);
        ${Util.firstToUpper($model.grammarName)}Parser parser = new ${Util.firstToUpper($model.grammarName)}Parser(tokens);

        // ParserRuleContext tree = parser.${model.rootClass().nameWithUpper()}();

        return convertToModel(parser.${model.rootClass().name}());
    }

    public ${Util.firstToUpper($model.grammarName)}Model convertToModel(${model.rootClass().nameWithUpper()}Context ctx) {

      ${Util.firstToUpper($model.grammarName)}Model model = ${Util.firstToUpper($model.grammarName)}Model.newInstance();

      model.setRoot(convert(ctx));

      return model;
    }

#foreach( $rcls in ${model.ruleClasses} )

    private ${rcls.nameWithUpper()} convert(${rcls.nameWithUpper()}Context ctx) {

#if($rcls.getChildClasses().isEmpty())

        // create model instance
        ${rcls.nameWithUpper()} ${rcls.nameWithLower()} = ${rcls.nameWithUpper()}.newInstance();
#foreach( $p in $rcls.properties )

#if($p.type.ruleType)
#if($p.type.arrayType)
        // convert elements of rule attribute $rcls.nameWithUpper().$p.nameWithLower()
        List<${p.type.asJavaTypeNameNoCollections()}> convertedElements$p.nameWithUpper() = ctx.${p.nameWithLower()}.stream().
            map(entry->convert(entry)).collect(Collectors.toList());
        // assign elements to model entity
        ${rcls.nameWithLower()}.get${p.nameWithUpper()}().addAll(convertedElements$p.nameWithUpper());
#else
        // convert and assign rule attribute $rcls.nameWithUpper().$p.nameWithLower()
        // if it is present
        if(ctx.${p.nameWithLower()}!=null) {
            ${rcls.nameWithLower()}.set${p.nameWithUpper()}(convert(ctx.${p.nameWithLower()}));
        }
#end## if array type
#else## if rule type
#if($p.type.arrayType)
        // convert elements of rule attribute $rcls.nameWithUpper().$p.nameWithLower()
        // TODO proper conversion of primitives, e.g., lexer rules to int, double etc.
        List<String> convertedElements$p.nameWithUpper() = ctx.${p.nameWithLower()}.stream().
            map(entry->entry.getText()).collect(Collectors.toList());
        // assign elements to model entity
        ${rcls.nameWithLower()}.get${p.nameWithUpper()}().addAll(convertedElements$p.nameWithUpper());
#else## if array type
        // convert and assign rule attribute $rcls.nameWithUpper().$p.nameWithLower()
        // if it is present
        if(ctx.${p.nameWithLower()}!=null) {
            ${rcls.nameWithLower()}.set${p.nameWithUpper()}(ctx.${p.nameWithLower()}.getText());
        }
#end## if array type
#end## if rule type
#end## foreach property in rule class

        return ${rcls.nameWithLower()};

#else## ?
        // -- BEGIN: delegate to labeled alternatives (child rule classes)
#foreach( $r in $rcls.childClasses )
        if(ctx instanceof ${r.nameWithUpper()}Context) {
            return convert((${r.nameWithUpper()}Context)ctx);
        }
#end## for-each child rule
        // -- END: delegate to labeled alternatives (child rule classes)

        // TODO 08.11.2017 prevent this from happening. The current design does not use rules with alt labeled directly but
        //                 only sub classes
        return ${rcls.nameWithUpper()}.newInstance();
#end## ?
    }


#end## foreach rule class


}
