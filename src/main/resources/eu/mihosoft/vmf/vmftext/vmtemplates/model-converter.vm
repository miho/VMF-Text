#*
 * Copyright 2016-2017 Michael Hoffer <info@michaelhoffer.de>. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * If you use this software for scientific research then please cite the following publication(s):
 *
 * M. Hoffer, C. Poliwoda, & G. Wittum. (2013). Visual reflection library:
 * a framework for declarative GUI programming on the Java platform.
 * Computing and Visualization in Science, 2013, 16(4),
 * 181â€“192. http://doi.org/10.1007/s00791-014-0230-y
 *#
package ${packageName};

// java core imports
import java.util.List;
import java.util.stream.Collectors;
import java.io.File;
import java.io.InputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.ByteArrayInputStream;
import java.nio.charset.StandardCharsets;

// antlr4 imports
import org.antlr.v4.runtime.CharStream;
import org.antlr.v4.runtime.CharStreams;
import org.antlr.v4.runtime.CommonTokenStream;
import org.antlr.v4.runtime.Token;
import org.antlr.v4.runtime.ParserRuleContext;

// model imports
import ${modelPackageName}.*;
import static ${packageName}.${Util.firstToUpper($model.grammarName)}Parser.*;

public final class ${Util.firstToUpper($model.grammarName)}ModelParser {

    // TODO remove this class if compile time conversions works
    // private final TypeConversionRegistry typeConversionRegistry

    public ${Util.firstToUpper($model.grammarName)}ModelParser() {
      // typeConversionRegistry = new TypeConversionRegistryImpl();
    }

    public ${Util.firstToUpper($model.grammarName)}Model parse(InputStream codeStream) throws IOException{
        CharStream input = CharStreams.fromStream(codeStream);

        ${Util.firstToUpper($model.grammarName)}Lexer lexer = new ${Util.firstToUpper($model.grammarName)}Lexer(input);
        CommonTokenStream tokens = new CommonTokenStream(lexer);
        ${Util.firstToUpper($model.grammarName)}Parser parser = new ${Util.firstToUpper($model.grammarName)}Parser(tokens);

        // ParserRuleContext tree = parser.${model.rootClass().nameWithUpper()}();

        return parse(parser.${model.rootClass().name}());
    }

    public ${Util.firstToUpper($model.grammarName)}Model parse(File code) throws IOException{
        try(FileInputStream codeStream = new FileInputStream(code)) {
            return parse(codeStream);
        }
    }

    public ${Util.firstToUpper($model.grammarName)}Model parse(String code) throws IOException{
        try(InputStream codeStream = new ByteArrayInputStream(code.getBytes(StandardCharsets.UTF_8.name()))) {
            return parse(codeStream);
        }
    }

    public ${Util.firstToUpper($model.grammarName)}Model parse(${model.rootClass().nameWithUpper()}Context ctx) {

      ${Util.firstToUpper($model.grammarName)}Model model = ${Util.firstToUpper($model.grammarName)}Model.newInstance();

      model.setRoot(convert(ctx));

      return model;
    }

#foreach( $rcls in ${model.ruleClasses} )

    private ${rcls.nameWithUpper()} convert(${rcls.nameWithUpper()}Context ctx) {

#if($rcls.getChildClasses().isEmpty())

        // ----------------------------------------
        // Initializing Rule Instance
        // ----------------------------------------

        // create model instance
        ${rcls.nameWithUpper()} ${rcls.nameWithLower()} = ${rcls.nameWithUpper()}.newInstance();

        // set code range (converted from antlr start and stop tokens)
        ${rcls.nameWithLower()}.setCodeRange(ctxToCodeRange(ctx));

        // ----------------------------------------
        // Converting Properties
        // ----------------------------------------
#foreach( $p in $rcls.properties )

#if($p.type.ruleType)
#if($p.type.arrayType)
        // convert elements of rule attribute $rcls.nameWithUpper().$p.nameWithLower()
        List<${p.type.asJavaTypeNameNoCollections()}> convertedElements$p.nameWithUpper() = ctx.${p.nameWithLower()}.stream().
            map(entry->convert(entry)).collect(Collectors.toList());
        // assign elements to model entity
        ${rcls.nameWithLower()}.get${p.nameWithUpper()}().addAll(convertedElements$p.nameWithUpper());
#else
        // convert and assign rule attribute $rcls.nameWithUpper().$p.nameWithLower()
        // if it is present
        if(ctx.${p.nameWithLower()}!=null) {
            ${rcls.nameWithLower()}.set${p.nameWithUpper()}(convert(ctx.${p.nameWithLower()}));
        }
#end## if array type
#else## if rule type
#if($p.type.arrayType)
        // convert elements of rule attribute $rcls.nameWithUpper().$p.nameWithLower()

        // proper conversion of primitives, e.g., lexer rules to int, double etc. depends on type mappings
        // pseudo-code:
        //
        // if p.type needs conversion then
        //   typemapping =  getTypeMappings(p.type.antlrRule)
        //   List <typeMapping.targetType> convertedElements = ... map(entry->typemapping.convert(entry)) ...
        //
           List<$model.getTypeMappings().targetTypeNameOfMapping($rcls.nameWithUpper(), $p.type.getAntlrRuleName())> convertedElements$p.nameWithUpper() =
           ctx.${p.nameWithLower()}.stream().map(entry->${model.getTypeMappings().conversionCodeOfMapping($rcls.nameWithUpper(), $p.type.getAntlrRuleName())}).
             collect(Collectors.toList());

        // FALLBACK: for lexer rules without conversion rules
        // List<String> convertedElements$p.nameWithUpper() = ctx.${p.nameWithLower()}.stream().
        //    map(entry->entry.getText()).collect(Collectors.toList());
        // assign elements to model entity
        ${rcls.nameWithLower()}.get${p.nameWithUpper()}().addAll(convertedElements$p.nameWithUpper());
#else## if array type
        // TODO proper conversion of primitives, e.g., lexer rules to int, double etc.
        // convert and assign rule attribute $rcls.nameWithUpper().$p.nameWithLower()
        // if it is present
        if(ctx.${p.nameWithLower()}!=null) {
            // FALLBACK:
            // ${rcls.nameWithLower()}.set${p.nameWithUpper()}(ctx.${p.nameWithLower()}.getText());
            Token entry = ctx.${p.nameWithLower()};
            ${rcls.nameWithLower()}.set${p.nameWithUpper()}(${model.getTypeMappings().conversionCodeOfMapping($rcls.nameWithUpper(), $p.type.getAntlrRuleName())});
        }
#end## if array type
#end## if rule type
#end## foreach property in rule class

        return ${rcls.nameWithLower()};

#else## ?
        // ----------------------------------------
        // Delegating to labeled alternatives:
        //
        // -> rules with alt-labels are never used
        //    directly but always delegate to child
        //    rules which inherit from the rule
        // ----------------------------------------

        // -- BEGIN: delegation
#foreach( $r in $rcls.childClasses )
        if(ctx instanceof ${r.nameWithUpper()}Context) {
            return convert((${r.nameWithUpper()}Context)ctx);
        }
#end## for-each child rule
        // -- END:   delegation

        // WARNING: 10.11.2017 This should not happen:
        //                     The current design does not use rules with alt labeled directly but
        //                     only sub classes
        // TODO: 10.11.2017    enforce validation/testing for this specific case
        System.err.println("VMF[WARNING]: rule-class '${r.nameWithUpper()}' must delegate to child classes.");
        return null;
#end## ?
    }


#end## foreach rule class

    // --------------------------------------------------------------------------------
    // UTILITY METHODS
    // --------------------------------------------------------------------------------

    public static CodeLocation tokenToCodeLocationStart(Token t) {
      return CodeLocation.newBuilder().
        withIndex(t.getStartIndex()).
          withCharPosInLine(t.getCharPositionInLine()).withLine(t.getLine()).build();
    }

    public static CodeLocation tokenToCodeLocationStop(Token t) {
      return CodeLocation.newBuilder().
        withIndex(t.getStopIndex()).
          withCharPosInLine(t.getCharPositionInLine()).withLine(t.getLine()).build();
    }

    public static CodeRange ctxToCodeRange(ParserRuleContext ctx) {
      return CodeRange.newBuilder().withStart(tokenToCodeLocationStart(ctx.start)).
        withStop(tokenToCodeLocationStop(ctx.stop)).build();
    }

// TODO remove this class if compile time conversion works
/*
    // --------------------------------------------------------------------------------
    // TYPE CONVERSION UTILITY CLASS
    // --------------------------------------------------------------------------------

    public TypeConversionRegistry getTypeConversionRegistry() {
        return typeConversionRegistry;
    }


    private static class TypeConversionRegistryImpl implements TypeConversionRegistry {

      private final Map<String, Map<String,TypeConverter>> converterMap = new HashMap<>();

      @Override
      public void registerConverter(TypeConverter t, String ruleClsName, String propertyRuleName, String outputTypeName) {
        getConverterMap(ruleClsName).put(propertyRuleName,t);
      }

      @Override
      public void registerConverter(TypeConverter t, String propertyRuleName, String outputTypeName) {
        getConverterMap("").put(propertyRuleName,t);
      }

      @Override
      public Object convert(String ruleClsName, String propertyRuleName, Object obj) {

        System.out.println("> conversion requested for '"+ruleClsName+"::"+propertyRuleName + "'");

        Map<String,TypeConverter> converters =
        getConverterMap(ruleClsName);

        if(converters.containsKey(propertyRuleName)) {
            System.out.println(" -> found converter registered for property type '"+propertyRuleName+"'.");

            TypeConverter tC = converters.get(propertyRuleName);

             return tC.convert(obj);
        }

        System.out.println(" -> looking for global converter for property type '"+propertyRuleName+"'.");

        Map<String,TypeConverter> globalConverters =
        getConverterMap("");

        if(globalConverters.containsKey(propertyRuleName)) {
            System.out.println("-> found global converter for property type '"+propertyRuleName+"'.");

            return globalConverters.get(propertyRuleName);
        }

            throw new RuntimeException("Cannot find requested type conversion for'"
              +ruleClsName+"::"+propertyRuleName + "'");
        }

        private Map<String,TypeConverter> getConverterMap(String ruleClassName) {

        Map<String,TypeConverter> result = converterMap.get(ruleClassName);


        if(result==null) {
            result = new HashMap<String,TypeConverter>();
            converterMap.put(ruleClassName, result);
        }

        return result;
      }
    } // end TypeConversionRegistryImpl

*/

}
