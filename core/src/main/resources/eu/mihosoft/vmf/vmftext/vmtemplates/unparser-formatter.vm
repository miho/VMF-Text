#*
 * Copyright 2017-2018 Michael Hoffer <info@michaelhoffer.de>. All rights reserved.
 * Copyright 2017-2018 Goethe Center for Scientific Computing, University Frankfurt. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * If you use this software for scientific research then please cite the following publication(s):
 *
 * M. Hoffer, C. Poliwoda, & G. Wittum. (2013). Visual reflection library:
 * a framework for declarative GUI programming on the Java platform.
 * Computing and Visualization in Science, 2013, 16(4),
 * 181â€“192. http://doi.org/10.1007/s00791-014-0230-y
 *#
package ${modelPackageName}.unparser;

import java.io.PrintWriter;
import java.io.IOException;
import java.util.Objects;
import java.util.Optional;

import eu.mihosoft.vmf.runtime.core.VMF;

import ${modelPackageName}.ReadOnlyCodeElement;
import ${modelPackageName}.CodeElement;
import ${modelPackageName}.CodeRange;

/**
 * Text formatting interface.
 */
public interface Formatter {

  /**
   * Pushes the current state onto the stack.
   */
  default void pushState()   {}

  /**
   * Accepts the current state, i.e., pops the current state but merges its content to the parent state retrieved via peek().
   */
  default void acceptState() {}

  /**
   * Rejects the current state, i.e., pops the current state without retaining its content.
   */
  default void rejectState() {}

  /**
   * This method is called to indicate that the rendering of the specified code element is done.
   * @param e code element
   * @param success indicates whether unparsing was successful 
   * @param w print writer that can be used to insert additional strings to the currently unparsed text
   */
  default void done(CodeElement e, boolean success, PrintWriter w) {}

  /**
   * Called prior to rendering an element. Can be used to insert additional text before rendering the
   * element. 
   * @param unparser the model unparser, i.e., top-level unparser
   * @param ruleInfo information about the rule that is currently rendered
   * @param w the print writer used to render the current element
   */
  default void pre( ${model.grammarName}ModelUnparser unparser, RuleInfo ruleInfo, PrintWriter w ){}

  /**
   * Renders an element. This method is called after the {@code pre()}-method and before the {@code post()}-method.
   *
   * @param unparser the model unparser, i.e., top-level unparser
   * @param ruleInfo information about the rule that is currently rendered
   * @param w the print writer used to render the current element
   * @param s the string representation of the current element (can be changed by the implementation of this method)
   */
  default void render(${model.grammarName}ModelUnparser unparser, RuleInfo ruleInfo, PrintWriter w, String s) {
    w.print(s);
  }

  /**
   * Called after rendering an element. Can be used to insert additional text after rendering the
   * element. 
   * @param unparser the model unparser, i.e., top-level unparser
   * @param ruleInfo information about the rule that is currently rendered
   * @param w the print writer used to render the current element
   */
  default void post(${model.grammarName}ModelUnparser unparser, RuleInfo ruleInfo, PrintWriter w ){}

  /**
   * Returns a new instance of the default formatter that supports lexical preservation, i.e., the default
   * formatter tries to reproduce white-spaces as accurately as possible.
   */
  static Formatter newDefaultFormatter() { return new DefaultFormatter();}

  /**
   * Returns a new instance of the default formatte without support for lexical preservation. This
   * is recommended whenever the format of the textual representation isn't relevant and if performace is
   * crutial.
   */
  static Formatter newDefaultFormatterWithoutLexicalPreservation() { 
    return new DefaultFormatterWithoutLexicalPreservation();
  }

  /**
   * TODO
   */
  @Deprecated 
  static Formatter newJavaStyleFormatter() { return new JavaStyleFormatter();}

  static enum RuleType {
    LEXER_RULE,
    TERMINAL,
    NONE
  }

  /**
   * This class stores information about the element rule to enable custom rendering behavior.
   */
  static final class RuleInfo {

    private final CodeElement parentObject;
    private final RuleType ruleType;
    private final String ruleName;
    private final String ruleText;

    // like xpath, i.e., /r37/a5/sr2 -> sub-rule 2 inside alternative 5 of rule 37
    private final String rulePath;

    // an unlabeled rule, i.e. a rule that's not represented as property
    private final boolean unnamed; 

    // indicates whether this rule is optional and its validity isn't defined by properties
    // Examples:
    // (1) name=IDENTIFIER ';'?
    // (2) ('(' assignments+=assignment* ')')?
    private final boolean optional; 

    // like (',' names+=IDENTIFIER)*  
    private final String grammarText;

    // consumed
    private boolean consumed;

    private RuleInfo(CodeElement parentObject, RuleType ruleType, String ruleName, String ruleText,
                     String rulePath, boolean unnamed, boolean optional, String grammarText) {
      this.parentObject = parentObject;
      this.ruleType = ruleType;
      this.ruleName = ruleName;
      this.ruleText = ruleText;

      this.rulePath = rulePath;
      this.unnamed  = unnamed;
      this.optional = optional;
      this.grammarText = grammarText;
    }

    public static RuleInfo emptyRule() {
      return new RuleInfo(
        new CodeElement() {
            @Override
            public CodeRange getCodeRange() {
                throw new UnsupportedOperationException("Empty Code Element does not support this operation.");
            }

            @Override
            public void setCodeRange(CodeRange codeRange) {
                throw new UnsupportedOperationException("Empty Code Element does not support this operation.");
            }

            @Override
            public void setPayload(Object payload) {
                throw new UnsupportedOperationException("Empty Code Element does not support this operation.");
            }

            @Override
            public Object getPayload() {
                throw new UnsupportedOperationException("Empty Code Element does not support this operation.");
            }

            @Override
            public CodeElement getParent() {
                throw new UnsupportedOperationException("Empty Code Element does not support this operation.");
            }

            @Override
            public void setParent(CodeElement parent) {
                throw new UnsupportedOperationException("Empty Code Element does not support this operation.");
            }

            @Override
            public CodeElement root() {
                throw new UnsupportedOperationException("Empty Code Element does not support this operation.");
            }

            @Override
            public eu.mihosoft.vcollections.VList<CodeElement> pathToRoot() {
                throw new UnsupportedOperationException("Empty Code Element does not support this operation.");
            }

            @Override
            public ReadOnlyCodeElement asReadOnly() {
                throw new UnsupportedOperationException("Empty Code Element does not support this operation.");
            }

            @Override
            public VMF vmf() {
                throw new UnsupportedOperationException("Empty Code Element does not support this operation.");
            }

            @Override
            public CodeElement clone() {
                throw new UnsupportedOperationException("Empty Code Element does not support this operation.");
            }
        }, RuleType.NONE, "","", "", true, false, "");
    }

   /**
    * Calling this method consumes the current rule. This method only has an effect if called inside
    * the {@code Formatter.pre()} method.
    */
    public void consume() {
      this.consumed = true;
    }

    boolean isConsumed() {
      return this.consumed;
    }

    /*package private*/ static RuleInfo newRuleInfo(CodeElement parentObject, RuleType ruleType, String ruleName, String ruleText, 
        String rulePath, boolean unnamed, boolean optional, String grammarText) {
      return new RuleInfo(parentObject, ruleType, ruleName, ruleText, rulePath, unnamed, optional, grammarText);
    }

    public CodeElement getParentObject() {
      return this.parentObject;
    }

    public RuleType getRuleType() {
      return this.ruleType;
    }

    public Optional<String> getRuleName() {
      return Optional.ofNullable(this.ruleName);
    }

    public String getRuleText() {
      return this.ruleText;
    }

    public String getRulePath() {
      return this.rulePath;
    }

    public boolean isUnnamed() {
      return this.unnamed;
    }

    public boolean isOptional() {
      return this.optional;
    }

    public String getGrammarText() {
      return this.grammarText;
    }


  }
}

// ------------------------------------------------------------
// DEFAULT FORMATTER (with lexical preservation and without) 
// ------------------------------------------------------------

  class DefaultFormatterWithoutLexicalPreservation implements Formatter {
    public void post(${model.grammarName}ModelUnparser unparser, RuleInfo ruleInfo, PrintWriter w ) {
      w.append(" ");
    }
  }

  class DefaultFormatter extends BaseFormatter {

    private CodeElement currentElement;

    private boolean consumeElement = false;
    
    DefaultFormatter() {
        //
    }

    @Override
    public void done(CodeElement e, boolean success, PrintWriter w) {

      // In case there's another ws we emit it. This is important
      // in case of white spaces between the last terminal and EOF.
      int pos = getHiddenTextCounter(e);
      if(getHiddenText(e)!=null && pos < getHiddenText(e).size()) {
        String ws = getHiddenText(e).get(pos);
        w.append(ws);
      } 

      // now reset the counter information for reconstructing WS info
      reset(e);
      currentElement = null;
    }

    @Override
    public void rejectState() {
        super.rejectState();

        if(currentElement!=null) {
          reset(currentElement);
        }
    }

    @Override
    public void acceptState() {
        super.acceptState();

//        if(currentElement!=null) {
//          reset(currentElement);
//        }
    }

    private void incHiddenTextCounter(CodeElement e) {

        if(e.getPayload()==null) {
          return;
        }

        if(!(e.getPayload() instanceof java.util.Map)) {
          throw new RuntimeException("Only instances of java.util.Map are supported as payload object.");
        }

        Integer value = (Integer)
                ((java.util.Map<String,Object>)e.getPayload()).get("vmf-text:formatter:hidden-text-counter");
        if(value==null) {
            value = 0;
        }
        ((java.util.Map<String,Object>)e.getPayload()).put("vmf-text:formatter:hidden-text-counter",++value);
    }
    private void decHiddenTextCounter(CodeElement e) {

        if(e.getPayload()==null) {
          return;
        }

        if(!(e.getPayload() instanceof java.util.Map)) {
          throw new RuntimeException("Only instances of java.util.Map are supported as payload object.");
        }

        Integer value = (Integer)
                ((java.util.Map<String,Object>)e.getPayload()).get("vmf-text:formatter:hidden-text-counter");
        if(value==null) {
            value = 0;
        }
        ((java.util.Map<String,Object>)e.getPayload()).put("vmf-text:formatter:hidden-text-counter",--value);
    }
    private void incOptionalSymbolsCounter(CodeElement e) {

        if(e.getPayload()==null) {
          return;
        }

        if(!(e.getPayload() instanceof java.util.Map)) {
          throw new RuntimeException("Only instances of java.util.Map are supported as payload object.");
        }

        Integer value = (Integer)
                ((java.util.Map<String,Object>)e.getPayload()).get("vmf-text:formatter:optional-symbols-counter");
        if(value==null) {
            value = 0;
        }
        ((java.util.Map<String,Object>)e.getPayload()).put("vmf-text:formatter:optional-symbols-counter",++value);
    }
    private void decOptionalSymbolsCounter(CodeElement e) {

        if(e.getPayload()==null) {
          return;
        }

        if(!(e.getPayload() instanceof java.util.Map)) {
          throw new RuntimeException("Only instances of java.util.Map are supported as payload object.");
        }

        Integer value = (Integer)
                ((java.util.Map<String,Object>)e.getPayload()).get("vmf-text:formatter:optional-symbols-counter");
        if(value==null) {
            value = 0;
        }
        ((java.util.Map<String,Object>)e.getPayload()).put("vmf-text:formatter:optional-symbols-counter",--value);
    }
    private void reset(CodeElement e) {

        if(e.getPayload()==null) {
          return;
        }

        if(!(e.getPayload() instanceof java.util.Map)) {
          throw new RuntimeException("Only instances of java.util.Map are supported as payload object.");
        }

        ((java.util.Map<String,Object>)e.getPayload()).put("vmf-text:formatter:hidden-text-counter",0);
        ((java.util.Map<String,Object>)e.getPayload()).put("vmf-text:formatter:optional-symbols-counter",0);
    }
    private int getHiddenTextCounter(CodeElement e) {

        if(e.getPayload()==null) {
          return 0;
        }

        if(!(e.getPayload() instanceof java.util.Map)) {
          throw new RuntimeException("Only instances of java.util.Map are supported as payload object.");
        }

        Integer value = (Integer)
                ((java.util.Map<String,Object>)e.getPayload()).get("vmf-text:formatter:hidden-text-counter");
        if(value==null) {
            value = 0;
        }
        return value;
    }
    private java.util.List<String> getHiddenText(CodeElement e) {

        if(e.getPayload()==null) {
          return null;
        }

        if(!(e.getPayload() instanceof java.util.Map)) {
          throw new RuntimeException("Only instances of java.util.Map are supported as payload object.");
        }
         
        java.util.Map<String,Object> payload = (java.util.Map<String,Object>)e.getPayload();

        return (java.util.List<String>)payload.get("vmf-text:ignored-pieces-of-text");
    }

    private java.util.List<Boolean> getOptionalSymbolState(CodeElement e) {

        if(e.getPayload()==null) {
          return null;
        }

        if(!(e.getPayload() instanceof java.util.Map)) {
          throw new RuntimeException("Only instances of java.util.Map are supported as payload object.");
        }
         
        java.util.Map<String,Object> payload = (java.util.Map<String,Object>)e.getPayload();

        return (java.util.List<Boolean>)payload.get("vmf-text:optionalSymbols");
    }

    private int getOptionalSymbolsCounter(CodeElement e) {

        if(e.getPayload()==null) {
          return 0;
        }

        if(!(e.getPayload() instanceof java.util.Map)) {
          throw new RuntimeException("Only instances of java.util.Map are supported as payload object.");
        }

        Integer value = (Integer)
                ((java.util.Map<String,Object>)e.getPayload()).get("vmf-text:formatter:optional-symbols-counter");
        if(value==null) {
            value = 0;
        }
        return value;
    }

    @Override
    public void pre(${model.grammarName}ModelUnparser unparser, RuleInfo ruleInfo, PrintWriter w) {
        // if(ruleInfo.getRuleType()==RuleType.TERMINAL || ruleInfo.getRuleType()==RuleType.LEXER_RULE) {

            consumeElement = false;

            CodeElement e = ruleInfo.getParentObject();
            currentElement = e;

            // skip effectively optional elements depending on state
            if(ruleInfo.isOptional()) {

                boolean symbolState = false;

                if(getOptionalSymbolState(e)==null) {
                  System.err.println("OptionalSymbolState NULL: Rule-Info: " + ruleInfo.getGrammarText() + " -> " + ruleInfo.getRuleName());
                } else {

                  int pos = getOptionalSymbolsCounter(e);
                  if(pos < getOptionalSymbolState(e).size()) {
                    symbolState = getOptionalSymbolState(e).get(pos);
                    incOptionalSymbolsCounter(e);
                  }

                }

                if(!symbolState) {
                  ruleInfo.consume();
                  System.out.println("Rule-Info: " + ruleInfo.getGrammarText() + " -> " + ruleInfo.getRuleName());
                  consumeElement = true;
                }

                return;
            }

            if(getHiddenText(e)!=null && !getHiddenText(e).isEmpty()) {
                int pos = getHiddenTextCounter(e);
                if(pos < getHiddenText(e).size()) {
                  String ws = getHiddenText(e).get(pos);
                  w.append(ws);
                  incHiddenTextCounter(e);
                } else {
                  w.append(" ");
                  String errorMsg = "ERROR: index=" + pos + ", " + e.getClass().getName() + ", size: " + getHiddenText(e).size();
                  System.err.println(errorMsg);
                  /*Since 17.10.2018 we don't tolerate hidden-text related problems*/
                  throw new RuntimeException(errorMsg);
                }
            } else {
                w.append(" ");
            }
        // }
    }

    public void render(${model.grammarName}ModelUnparser unparser, RuleInfo ruleInfo, PrintWriter w, String s) {
      if(!consumeElement) {
        w.print(s);
      }
    }

    @Override
    public void post(${model.grammarName}ModelUnparser unparser, RuleInfo ruleInfo, PrintWriter w) {

    }
  } // end default-formatter


class JavaStyleFormatter implements Formatter {

  private String last = "";
  private String indent = "";

  String getIndent() {
    return indent;
  }

  void incHiddenTextCounter() {
    indent+="  ";
  }

  void decHiddenTextCounter() {
    if(indent.length() > 1) {
      indent=indent.substring(2);
    }
  }

  public void pre( ${model.grammarName}ModelUnparser unparser, RuleInfo ruleInfo, PrintWriter w ) {



    if(Objects.equals(ruleInfo.getRuleText(), "}")) {
      decHiddenTextCounter();
      w.append('\n').append(getIndent());
    }
  }
  public void post(${model.grammarName}ModelUnparser unparser, RuleInfo ruleInfo, PrintWriter w ) {
    if(Objects.equals(ruleInfo.getRuleText(), "{")) {
      incHiddenTextCounter();
      w.append('\n').append(getIndent());
    } else if(Objects.equals(ruleInfo.getRuleText(), ";")) {
      w.append('\n').append(getIndent());
    } else{
      w.append(" ");
    }

    last = ruleInfo.getRuleText();
  }
}
