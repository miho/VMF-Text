#*
 * Copyright 2017-2018 Michael Hoffer <info@michaelhoffer.de>. All rights reserved.
 * Copyright 2017-2018 Goethe Center for Scientific Computing, University Frankfurt. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * If you use this software for scientific research then please cite the following publication(s):
 *
 * M. Hoffer, C. Poliwoda, & G. Wittum. (2013). Visual reflection library:
 * a framework for declarative GUI programming on the Java platform.
 * Computing and Visualization in Science, 2013, 16(4),
 * 181â€“192. http://doi.org/10.1007/s00791-014-0230-y
 *#
package ${modelPackageName}.unparser;

import java.io.PrintWriter;
import java.io.IOException;
import java.util.Objects;
import java.util.Optional;

import eu.mihosoft.vmf.runtime.core.VMF;

import ${modelPackageName}.ReadOnlyCodeElement;
import ${modelPackageName}.CodeElement;
import ${modelPackageName}.CodeRange;

public interface Formatter {

  default void pushState()   {}
  default void acceptState() {}
  default void rejectState() {}

  /**
   * This method is called to indicate that the rendering of the specified code element is done.
   * @param e code element
   * @param success indicates whether unparsing was successful 
   * @param w print writer that can be used to insert additional strings to the currently unparsed text
   */
  default void done(CodeElement e, boolean success, PrintWriter w) {}

  /**
   * Called prior to rendering an element. Can be used to insert additional text before rendering the
   * element. 
   * @param unparser the model unparser, i.e., top-level unparser
   * @param ruleInfo information about the rule that is currently rendered
   * @param w the print writer used to render the current element
   */
  default void pre( ${model.grammarName}ModelUnparser unparser, RuleInfo ruleInfo, PrintWriter w ){}

  /**
   * Renderes an element. This method is called after the {@code pre()}-method and before the {@code post()}-method.
   *
   * @param unparser the model unparser, i.e., top-level unparser
   * @param ruleInfo information about the rule that is currently rendered
   * @param w the print writer used to render the current element
   * @param s the string representation of the current element (can be changed by the implementation of this method)
   */
  default void render(${model.grammarName}ModelUnparser unparser, RuleInfo ruleInfo, PrintWriter w, String s) {
    w.print(s);
  }

  /**
   * Called after rendering an element. Can be used to insert additional text after rendering the
   * element. 
   * @param unparser the model unparser, i.e., top-level unparser
   * @param ruleInfo information about the rule that is currently rendered
   * @param w the print writer used to render the current element
   */
  default void post(${model.grammarName}ModelUnparser unparser, RuleInfo ruleInfo, PrintWriter w ){}

  /**
   * Returns a new instance of the default formatter that supports lexical preservation, i.e., the default
   * formatter tries to reproduce white-spaces as accurately as possible.
   */
  static Formatter newDefaultFormatter() { return new DefaultFormatter();}

  /**
   * Returns a new instance of the default formatte without support for lexical preservation. This
   * is recommended whenever the format of the textual representation isn't relevant and if performace is
   * crutial.
   */
  static Formatter newDefaultFormatterWithoutLexicalPreservation() { 
    return new DefaultFormatterWithoutLexicalPreservation();
  }

  /**
   * TODO
   */
  @Deprecated 
  static Formatter newJavaStyleFormatter() { return new JavaStyleFormatter();}

  static enum RuleType {
    LEXER_RULE,
    TERMINAL,
    NONE
  }

  /**
   * This class stores information about the element rule to enable custom rendering behavior.
   */
  static final class RuleInfo {

    private final CodeElement parentObject;
    private final RuleType ruleType;
    private final String ruleName;
    private final String ruleText;

    // consumed
    private boolean consumed;

    private RuleInfo(CodeElement parentObject, RuleType ruleType, String ruleName, String ruleText) {
      this.parentObject = parentObject;
      this.ruleType = ruleType;
      this.ruleName = ruleName;
      this.ruleText = ruleText;
    }

    public static RuleInfo emptyRule() {
      return new RuleInfo(
        new CodeElement() {
            @Override
            public CodeRange getCodeRange() {
                throw new UnsupportedOperationException("Empty Code Element does not support this operation.");
            }

            @Override
            public void setCodeRange(CodeRange codeRange) {
                throw new UnsupportedOperationException("Empty Code Element does not support this operation.");
            }

            @Override
            public void setPayload(Object payload) {
                throw new UnsupportedOperationException("Empty Code Element does not support this operation.");
            }

            @Override
            public Object getPayload() {
                throw new UnsupportedOperationException("Empty Code Element does not support this operation.");
            }

            @Override
            public CodeElement getParent() {
                throw new UnsupportedOperationException("Empty Code Element does not support this operation.");
            }

            @Override
            public void setParent(CodeElement parent) {
                throw new UnsupportedOperationException("Empty Code Element does not support this operation.");
            }

            @Override
            public CodeElement root() {
                throw new UnsupportedOperationException("Empty Code Element does not support this operation.");
            }

            @Override
            public eu.mihosoft.vcollections.VList<CodeElement> pathToRoot() {
                throw new UnsupportedOperationException("Empty Code Element does not support this operation.");
            }

            @Override
            public ReadOnlyCodeElement asReadOnly() {
                throw new UnsupportedOperationException("Empty Code Element does not support this operation.");
            }

            @Override
            public VMF vmf() {
                throw new UnsupportedOperationException("Empty Code Element does not support this operation.");
            }

            @Override
            public CodeElement clone() {
                throw new UnsupportedOperationException("Empty Code Element does not support this operation.");
            }
        }, RuleType.NONE, "","");
    }

   /**
    * Calling this method consumes the current rule. This method only has an effect if called inside
    * the {@code Formatter.pre()} method.
    */
    public void consume() {
      this.consumed = true;
    }

    boolean isConsumed() {
      return this.consumed;
    }

    /*package private*/ static RuleInfo newRuleInfo(CodeElement parentObject, RuleType ruleType, String ruleName, String ruleText) {
      return new RuleInfo(parentObject, ruleType, ruleName, ruleText);
    }

    public CodeElement getParentObject() {
      return this.parentObject;
    }

    public RuleType getRuleType() {
      return this.ruleType;
    }

    public Optional<String> getRuleName() {
      return Optional.ofNullable(this.ruleName);
    }

    public String getRuleText() {
      return this.ruleText;
    }
  }
}

// ------------------------------------------------------------
// DEFAULT FORMATTER (with lexical preservation and without) 
// ------------------------------------------------------------

  class DefaultFormatterWithoutLexicalPreservation implements Formatter {
    public void post(${model.grammarName}ModelUnparser unparser, RuleInfo ruleInfo, PrintWriter w ) {
      w.append(" ");
    }
  }

  class DefaultFormatter extends BaseFormatter {

    private CodeElement currentElement;
    
    DefaultFormatter() {
        //
    }

    @Override
    public void done(CodeElement e, boolean success, PrintWriter w) {

      // In case there's another ws we emit it. This is important
      // in case of white spaces between the last terminal and EOF.
      int pos = getCounter(e);
      if(getHiddenText(e)!=null && pos < getHiddenText(e).size()) {
        String ws = getHiddenText(e).get(pos);
        w.append(ws);
      } 

      // now reset the counter information for reconstructing WS info
      reset(e);
      currentElement = null;
    }

    @Override
    public void rejectState() {
        super.rejectState();

        if(currentElement!=null) {
          reset(currentElement);
        }
    }

    @Override
    public void acceptState() {
        super.acceptState();

//        if(currentElement!=null) {
//          reset(currentElement);
//        }
    }

    private void inc(CodeElement e) {

        if(e.getPayload()==null) {
          return;
        }

        if(!(e.getPayload() instanceof java.util.Map)) {
          throw new RuntimeException("Only instances of java.util.Map are supported as payload object.");
        }

        Integer value = (Integer)
                ((java.util.Map<String,Object>)e.getPayload()).get("vmf-text:formatter:counter");
        if(value==null) {
            value = 0;
        }
        ((java.util.Map<String,Object>)e.getPayload()).put("vmf-text:formatter:counter",++value);
    }
    private void dec(CodeElement e) {

        if(e.getPayload()==null) {
          return;
        }

        if(!(e.getPayload() instanceof java.util.Map)) {
          throw new RuntimeException("Only instances of java.util.Map are supported as payload object.");
        }

        Integer value = (Integer)
                ((java.util.Map<String,Object>)e.getPayload()).get("vmf-text:formatter:counter");
        if(value==null) {
            value = 0;
        }
        ((java.util.Map<String,Object>)e.getPayload()).put("vmf-text:formatter:counter",--value);
    }
    private void reset(CodeElement e) {

        if(e.getPayload()==null) {
          return;
        }

        if(!(e.getPayload() instanceof java.util.Map)) {
          throw new RuntimeException("Only instances of java.util.Map are supported as payload object.");
        }

        ((java.util.Map<String,Object>)e.getPayload()).put("vmf-text:formatter:counter",0);
    }
    private int getCounter(CodeElement e) {

        if(e.getPayload()==null) {
          return 0;
        }

        if(!(e.getPayload() instanceof java.util.Map)) {
          throw new RuntimeException("Only instances of java.util.Map are supported as payload object.");
        }

        Integer value = (Integer)
                ((java.util.Map<String,Object>)e.getPayload()).get("vmf-text:formatter:counter");
        if(value==null) {
            value = 0;
        }
        return value;
    }
    private java.util.List<String> getHiddenText(CodeElement e) {

        if(e.getPayload()==null) {
          return null;
        }

        if(!(e.getPayload() instanceof java.util.Map)) {
          throw new RuntimeException("Only instances of java.util.Map are supported as payload object.");
        }
         
        java.util.Map<String,Object> payload = (java.util.Map<String,Object>)e.getPayload();

        return (java.util.List<String>)payload.get("vmf-text:ignored-pieces-of-text");
    }
    @Override
    public void pre(${model.grammarName}ModelUnparser unparser, RuleInfo ruleInfo, PrintWriter w) {
        // if(ruleInfo.getRuleType()==RuleType.TERMINAL || ruleInfo.getRuleType()==RuleType.LEXER_RULE) {
            CodeElement e = ruleInfo.getParentObject();
            currentElement = e;
            if(getHiddenText(e)!=null && !getHiddenText(e).isEmpty()) {
                int pos = getCounter(e);
                if(pos < getHiddenText(e).size()) {
                  String ws = getHiddenText(e).get(pos);
                  w.append(ws);
                  inc(e);
                } else {
                  w.append(" ");
                  System.err.println("ERROR: index=" + pos + ", " + e.getClass().getName());
                }
            } else {
                w.append(" ");
            }
        // }
    }
    @Override
    public void post(${model.grammarName}ModelUnparser unparser, RuleInfo ruleInfo, PrintWriter w) {

    }
  } // end default-formatter


class JavaStyleFormatter implements Formatter {

  private String last = "";
  private String indent = "";

  String getIndent() {
    return indent;
  }

  void inc() {
    indent+="  ";
  }

  void dec() {
    if(indent.length() > 1) {
      indent=indent.substring(2);
    }
  }

  public void pre( ${model.grammarName}ModelUnparser unparser, RuleInfo ruleInfo, PrintWriter w ) {



    if(Objects.equals(ruleInfo.getRuleText(), "}")) {
      dec();
      w.append('\n').append(getIndent());
    }
  }
  public void post(${model.grammarName}ModelUnparser unparser, RuleInfo ruleInfo, PrintWriter w ) {
    if(Objects.equals(ruleInfo.getRuleText(), "{")) {
      inc();
      w.append('\n').append(getIndent());
    } else if(Objects.equals(ruleInfo.getRuleText(), ";")) {
      w.append('\n').append(getIndent());
    } else{
      w.append(" ");
    }

    last = ruleInfo.getRuleText();
  }
}
